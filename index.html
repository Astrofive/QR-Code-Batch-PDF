<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>QR Code PDF Generator</title>

<!-- Libs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcode-generator/1.4.4/qrcode.min.js" crossorigin="anonymous"></script>

<style>
  *{box-sizing:border-box;margin:0;padding:0}
  body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#0b1220,#0f172e,#1e293b);color:#e5e7eb;min-height:100vh;padding:32px}
  .container{max-width:1400px;margin:0 auto}
  h1{font-size:32px;font-weight:800;letter-spacing:-.02em;margin-bottom:12px}
  .grid{display:grid;grid-template-columns:420px 1fr;gap:24px}
  .space-y-6{display:flex;flex-direction:column;gap:18px}
  .panel{background:#475569;border-radius:10px;padding:18px}
  .panel h2{font-size:18px;margin-bottom:10px}
  .upload-label{display:block;border:1.5px dashed #93c5fd;background:#334155;border-radius:12px;padding:14px;text-align:center;cursor:pointer;transition:background .2s,border .2s}
  .upload-label input{display:none}
  .upload-label.drag{outline:3px dashed #93c5fd;outline-offset:4px;background:#3b4759}
  .success-text{margin-top:8px;font-size:14px;color:#86efac}
  .row{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
  .pill{display:flex;align-items:center;gap:8px;background:#334155;border-radius:999px;padding:8px 12px;font-size:14px}
  .small{font-size:12px;color:#cbd5e1}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .btn{width:100%;background:#16a34a;color:#fff;border:none;padding:12px 14px;border-radius:10px;font-size:16px;font-weight:700}
  .btn:disabled{background:#475569;opacity:.6}
  .canvas-container{background:#1e293b;border-radius:10px;padding:18px;height:100%;display:flex;flex-direction:column}
  #stage{position:relative;flex:1;background:#0f172e;border:2px solid #475569;border-radius:10px;overflow:hidden;user-select:none}
  #stage img{display:block;max-width:100%;max-height:100%}
  .empty{height:100%;display:grid;place-items:center;color:#9ca3af}
  .qr-box{position:absolute;border:2px solid #60a5fa;background:rgba(96,165,250,.12);cursor:move;transition:.05s}
  .qr-box.selected{border-color:#4ade80;background:rgba(74,222,128,.12)}
  .qr-box .label{position:absolute;top:-18px;left:0;font-size:12px;font-weight:700}
  /* label preview is draggable */
  .label-area{position:absolute;pointer-events:auto;cursor:move}
  .box-info{margin-top:10px;padding:10px;background:#334155;border-radius:8px;font-size:14px}
</style>
</head>
<body>

  <div class="container">
    <h1>QR Code PDF Generator</h1>
    <div class="grid">
      <div class="space-y-6">
        <div class="panel">
          <h2>1) Upload CSV (Building, Floor, Space, URI)</h2>
          <label class="upload-label" id="csvDrop">
            üì§ Choose CSV or drag & drop
            <input type="file" id="csvFile" accept=".csv,text/csv"/>
          </label>
          <div id="csvStatus" class="success-text"></div>
        </div>

        <div class="panel">
          <h2>2) Upload Template Image</h2>
          <label class="upload-label" id="imgDrop">
            üì§ Choose Image or drag & drop
            <input type="file" id="imageFile" accept="image/*"/>
          </label>
          <div id="imageStatus" class="success-text"></div>
        </div>

        <div class="panel">
          <h2>3) Place QR Codes</h2>
          <div class="row small" style="margin-bottom:10px;">
            <div>‚Ä¢ Click image to add box ‚Ä¢ Drag to move ‚Ä¢ Backspace to delete</div>
          </div>

          <!-- Size controls (pixels) -->
          <div class="pill" style="gap:12px;flex-wrap:wrap;">
            <div style="display:flex;align-items:center;gap:8px;">
              <label class="small" for="qrSizePx">QR size (px)</label>
              <input type="number" id="qrSizePx" min="1" step="1" value="100" style="width:92px;padding:4px;border-radius:6px;border:1px solid #64748b;background:#334155;color:#e5e7eb;" />
            </div>
            <div style="display:flex;align-items:center;gap:8px;">
              <label class="small" for="labelFontPx">Label font (px)</label>
              <input type="number" id="labelFontPx" min="1" step="1" value="18" style="width:92px;padding:4px;border-radius:6px;border:1px solid #64748b;background:#334155;color:#e5e7eb;" />
            </div>
          </div>

          <div class="row">
            <div class="pill"><label><input type="checkbox" id="snapToggle"/> Snap 8px</label></div>
            <div class="pill"><label><input type="checkbox" id="showText" checked/> Add label</label></div>
          </div>

          <div class="row" id="labelFieldsPill" style="gap:10px;flex-wrap:wrap;">
            <span class="small">Show:</span>
            <label class="small"><input type="checkbox" id="showBuilding" checked/> Building</label>
            <label class="small"><input type="checkbox" id="showFloor" checked/> Floor</label>
            <label class="small"><input type="checkbox" id="showSpace" checked/> Space</label>
            <span class="small">Sep:</span>
            <input id="labelSep" class="small mono" value=" / " style="width:48px;padding:4px;border-radius:6px;border:1px solid #64748b;background:#334155;color:#e5e7eb;" />
          </div>

          <div class="row">
            <div class="pill">
              <label for="textColor">Label Color</label>
              <input type="color" id="textColor" value="#8c8c8c" title="Choose label color"/>
            </div>
            <button class="pill" id="clearBtn" type="button">Clear boxes</button>
          </div>
        </div>

        <button class="btn" id="generateBtn" disabled>‚¨áÔ∏è Generate PDF</button>
      </div>

      <div class="canvas-container">
        <h2>Template Editor</h2>
        <div id="stage" class="empty">Upload a template image to begin</div>
        <div class="box-info" id="boxInfo">No boxes yet. Click on the image to add one. Backspace to delete selected.</div>
      </div>
    </div>
  </div>

<script>
/* ---------- State ---------- */
let csvRows = [];                  // [{building,floor,space,uri}]
let templateDataURL = null;
let imgEl = null;
let boxes = [];                    // [{xPct,yPct,sizePct,labelXPct?,labelYPct?}]
let selectedIdx = null;
let dragging = false;
let dragMode = null;               // 'qr' | 'label' | null
let dragOffset = {x:0,y:0};
let labelColor = '#8c8c8c';
let qrSizePx = 100;                // absolute pixels
let labelFontPx = 18;              // absolute pixels
let handlersBound = false;         // prevent duplicate global handlers

/* ---------- DOM ---------- */
const stage        = document.getElementById('stage');
const csvFile      = document.getElementById('csvFile');
const imageFile    = document.getElementById('imageFile');
const csvDrop      = document.getElementById('csvDrop');
const imgDrop      = document.getElementById('imgDrop');

const csvStatus    = document.getElementById('csvStatus');
const imageStatus  = document.getElementById('imageStatus');
const boxInfo      = document.getElementById('boxInfo');

const snapToggle   = document.getElementById('snapToggle');
const showText     = document.getElementById('showText');
const showBuildingEl = document.getElementById('showBuilding');
const showFloorEl    = document.getElementById('showFloor');
const showSpaceEl    = document.getElementById('showSpace');
const labelSepEl     = document.getElementById('labelSep');
const textColorInput = document.getElementById('textColor');

const qrSizePxEl     = document.getElementById('qrSizePx');
const labelFontPxEl  = document.getElementById('labelFontPx');

const generateBtn  = document.getElementById('generateBtn');
const clearBtn     = document.getElementById('clearBtn');

/* ---------- Helpers ---------- */
const clamp = (v,min,max)=> Math.max(min, Math.min(max, v));
const toInt = n => Math.round(Number(n)||0);

function enableGenerateIfReady(){
  generateBtn.disabled = !(csvRows.length && templateDataURL && boxes.length);
}
function updateBoxInfo(){
  boxInfo.textContent = boxes.length
    ? `Placed ${boxes.length} squares. Drag to move. Backspace to delete.`
    : 'No boxes yet. Click on the image to add one. Backspace to delete selected.';
}
function syncLabelFieldsVisibility(){
  const on = showText.checked;
  const pill = document.getElementById('labelFieldsPill');
  pill.style.opacity = on ? '1' : '0.5';
  pill.style.pointerEvents = on ? 'auto' : 'none';
}
showText.addEventListener('change', ()=>{ syncLabelFieldsVisibility(); renderBoxes(); });
textColorInput.addEventListener('input', e=>{ labelColor = e.target.value; renderBoxes(); });
syncLabelFieldsVisibility();

/* ---------- CSV ---------- */
function parseRows(rows){
  csvRows = rows.map(r=>{
    const [building, floor, space, uri] = r;
    if(!uri) return null;
    return {
      building: String(building??'').trim(),
      floor:    String(floor??'').trim(),
      space:    String(space??'').trim(),
      uri:      String(uri??'').trim()
    };
  }).filter(Boolean);
  csvStatus.textContent = `‚úì ${csvRows.length} items loaded`;
  updateBoxInfo();
  enableGenerateIfReady();
}
csvFile.addEventListener('change', e=>{
  const f = e.target.files?.[0]; if(!f) return;
  Papa.parse(f, {header:false, skipEmptyLines:true, complete: res=> parseRows(res.data)});
});

/* ---------- Image ---------- */
imageFile.addEventListener('change', e=>{
  const f = e.target.files?.[0]; if(f) handleImage(f);
});
function handleImage(file){
  const fr = new FileReader();
  fr.onload = ()=>{
    templateDataURL = fr.result;
    boxes = [];
    selectedIdx = null;
    drawStage();
    imageStatus.textContent = '‚úì Template loaded';
    updateBoxInfo();
    enableGenerateIfReady();
  };
  fr.readAsDataURL(file);
}
function drawStage(){
  stage.innerHTML = '';
  if(!templateDataURL){
    stage.className = 'empty';
    stage.textContent = 'Upload a template image to begin';
    return;
  }
  stage.className = '';
  imgEl = document.createElement('img');
  imgEl.src = templateDataURL;
  imgEl.style.userSelect='none';
  imgEl.draggable=false;
  stage.appendChild(imgEl);

  // Attach ONLY once per template image
  imgEl.addEventListener('mousedown', onStageMouseDown);

  if (!handlersBound){
    window.addEventListener('mouseup', ()=>{ dragging=false; dragMode=null; });
    handlersBound = true;
  }

  imgEl.onload = ()=>{ renderBoxes(); };
}

/* ---------- Size inputs (live) ---------- */
qrSizePxEl.addEventListener('input', ()=>{
  qrSizePx = Math.max(1, parseInt(qrSizePxEl.value||'0',10)||0);
  if(imgEl){
    const imgW = imgEl.getBoundingClientRect().width || 1;
    boxes.forEach(b=> b.sizePct = qrSizePx / imgW);
  }
  renderBoxes();
});
labelFontPxEl.addEventListener('input', ()=>{
  labelFontPx = Math.max(1, parseInt(labelFontPxEl.value||'0',10)||0);
  renderBoxes();
});

/* ---------- Render ---------- */
function renderBoxes(){
  [...stage.querySelectorAll('.qr-box,.label-area')].forEach(el=>el.remove());
  if(!imgEl) return;

  const {width: imgW, height: imgH} = imgEl.getBoundingClientRect();

  boxes.forEach((b, i)=>{
    const sizePx = Math.round(b.sizePct * imgW);
    const left   = b.xPct * imgW;
    const top    = b.yPct * imgH;

    const box = document.createElement('div');
    box.className = 'qr-box' + (i===selectedIdx ? ' selected' : '');
    box.style.left = left + 'px';
    box.style.top  = top  + 'px';
    box.style.width  = sizePx + 'px';
    box.style.height = sizePx + 'px';
    box.dataset.index = i;

    const lbl = document.createElement('div');
    lbl.className = 'label';
    lbl.textContent = i+1;
    box.appendChild(lbl);

    // Drag QR
    box.addEventListener('mousedown', (e)=>{
      e.preventDefault();
      selectedIdx = i;
      dragging = true;
      dragMode = 'qr';
      const imgRect = imgEl.getBoundingClientRect();
      dragOffset.x = e.clientX - imgRect.left - left;
      dragOffset.y = e.clientY - imgRect.top  - top;
      renderBoxes();
    });

    stage.appendChild(box);

    // Label preview (text only, draggable)
    if (showText.checked){
      const dataItem = csvRows[i] || null;
      const labelText = dataItem ? buildLabel(dataItem) : 'Label';
      const fontPx = Math.max(6, Math.round(labelFontPx||18));

      const labelBox = document.createElement('div');
      labelBox.className = 'label-area';
      labelBox.dataset.index = i;
      labelBox.style.width = sizePx + 'px';

      const textEl = document.createElement('div');
      textEl.style.position='relative';
      textEl.style.width='100%';
      textEl.style.fontWeight='700';
      textEl.style.fontSize = fontPx + 'px';
      textEl.style.lineHeight='1.2';
      textEl.style.textAlign='center';
      textEl.style.color = labelColor || '#8c8c8c';
      textEl.style.wordBreak='break-word';
      textEl.textContent = labelText;

      labelBox.appendChild(textEl);
      stage.appendChild(labelBox);

      // measure height (~up to 2 lines)
      const contentH = Math.min(Math.round(fontPx * 2 * 1.2), textEl.scrollHeight || Math.round(fontPx*1.2));

      // Position from saved pct or default under QR
      const hasSaved = (typeof b.labelXPct === 'number') && (typeof b.labelYPct === 'number');
      let leftLabel = hasSaved ? b.labelXPct * imgW : left;
      let topLabel  = hasSaved ? b.labelYPct  * imgH : (top + sizePx + 6);

      // Clamp
      leftLabel = clamp(leftLabel, 0, imgW - sizePx);
      topLabel  = clamp(topLabel,  0, imgH - contentH - 2);

      // Persist pct
      b.labelXPct = leftLabel / imgW;
      b.labelYPct = topLabel  / imgH;

      // Apply
      labelBox.style.left   = Math.round(leftLabel) + 'px';
      labelBox.style.top    = Math.round(topLabel)  + 'px';
      labelBox.style.height = contentH + 'px';

      // Drag label
      labelBox.addEventListener('mousedown', (e)=>{
        e.preventDefault();
        selectedIdx = i;
        dragging = true;
        dragMode = 'label';
        const imgRect = imgEl.getBoundingClientRect();
        dragOffset.x = e.clientX - imgRect.left - leftLabel;
        dragOffset.y = e.clientY - imgRect.top  - topLabel;
        renderBoxes();
      });
    }
  });
}

function onStageMouseDown(e){
  if(!imgEl) return;
  if (e.target && (e.target.closest('.qr-box') || e.target.closest('.label-area'))) return; // ignore when dragging existing

  const rect = imgEl.getBoundingClientRect();
  const imgW = rect.width || 1;
  const imgH = rect.height || 1;

  let sizePx = Math.max(10, Math.round(qrSizePx||100));
  let left = e.clientX - rect.left - sizePx/2;
  let top  = e.clientY - rect.top  - sizePx/2;

  if (snapToggle.checked){
    left = Math.round(left/8)*8;
    top  = Math.round(top/8)*8;
  }

  left = clamp(left, 0, imgW - sizePx);
  top  = clamp(top,  0, imgH - sizePx);

  const sizePct = sizePx / imgW;
  // Seed label position just under QR (approx 2 lines)
  const approxH = Math.round((labelFontPx||18) * 2 * 1.2);
  const labelLeftPx = left;
  const labelTopPx  = Math.min(imgH - approxH - 2, top + sizePx + 6);

  boxes.push({
    xPct: left/imgW,
    yPct: top/imgH,
    sizePct,
    labelXPct: labelLeftPx / imgW,
    labelYPct: labelTopPx  / imgH
  });
  selectedIdx = boxes.length - 1;
  renderBoxes();
  enableGenerateIfReady();
}

window.addEventListener('mousemove', (e)=>{
  if(!dragging || selectedIdx==null || !imgEl) return;
  const imgRect = imgEl.getBoundingClientRect();
  const imgW = imgRect.width || 1;
  const imgH = imgRect.height || 1;

  let left = e.clientX - imgRect.left - dragOffset.x;
  let top  = e.clientY - imgRect.top  - dragOffset.y;

  if (snapToggle.checked){
    left = Math.round(left/8)*8;
    top  = Math.round(top/8)*8;
  }

  if (dragMode === 'qr'){
    const sizePx = Math.round(boxes[selectedIdx].sizePct * imgW);
    left = clamp(left, 0, imgW - sizePx);
    top  = clamp(top,  0, imgH - sizePx);
    boxes[selectedIdx].xPct = left / imgW;
    boxes[selectedIdx].yPct = top  / imgH;
  } else if (dragMode === 'label'){
    const sizePx = Math.round(boxes[selectedIdx].sizePct * imgW);
    left = clamp(left, 0, imgW - sizePx);
    top  = clamp(top,  0, imgH - 4); // vertical soft clamp; refined in renderBoxes()
    boxes[selectedIdx].labelXPct = left / imgW;
    boxes[selectedIdx].labelYPct = top  / imgH;
  }

  renderBoxes();
});

window.addEventListener('keydown', (e)=>{
  if (e.key !== 'Backspace') return;

  const t = e.target;
  const isTyping = t && (
    t.tagName === 'INPUT' ||
    t.tagName === 'TEXTAREA' ||
    t.isContentEditable
  );
  if (isTyping) return;

  if (selectedIdx != null){
    e.preventDefault(); // avoid browser back
    boxes.splice(selectedIdx,1);
    selectedIdx = null;
    renderBoxes();
    updateBoxInfo();
    enableGenerateIfReady();
  }
});

clearBtn.addEventListener('click', ()=>{
  boxes = [];
  selectedIdx = null;
  renderBoxes();
  updateBoxInfo();
  enableGenerateIfReady();
});

/* ---------- DnD: ONLY on CSV & Image tiles ---------- */
function isImageFile(f){ return f && /^image\//.test(f.type); }
function isCSVFile(f){ return /\.csv$/i.test(f.name) || f.type === 'text/csv'; }

[csvDrop, imgDrop].forEach(zone=>{
  zone.addEventListener('dragenter', e=>{
    e.preventDefault();
    zone.classList.add('drag');
  });
  zone.addEventListener('dragover', e=>{
    e.preventDefault();
    if (e.dataTransfer) e.dataTransfer.dropEffect = 'copy';
  });
  zone.addEventListener('dragleave', e=>{
    zone.classList.remove('drag');
  });
  zone.addEventListener('drop', e=>{
    e.preventDefault();
    zone.classList.remove('drag');
    const files = Array.from(e.dataTransfer.files || []);
    if (!files.length) return;

    if (zone === csvDrop) {
      const csv = files.find(isCSVFile);
      if (csv) {
        Papa.parse(csv, { header:false, skipEmptyLines:true, complete: res => parseRows(res.data) });
      } else {
        alert('Please drop a .csv file on the CSV area.');
      }
    } else { // imgDrop
      const img = files.find(isImageFile);
      if (img) {
        handleImage(img);
      } else {
        alert('Please drop an image file on the image area.');
      }
    }
  });
});

/* ---------- Label text ---------- */
function buildLabel(item){
  const parts = [];
  if (showBuildingEl.checked && item.building) parts.push(item.building);
  if (showFloorEl.checked    && item.floor)    parts.push(item.floor);
  if (showSpaceEl.checked    && item.space)    parts.push(item.space);
  if (!parts.length) return '';
  return parts.join(labelSepEl.value ?? ' / ');
}

/* ---------- QR rendering ---------- */
function makeQRCanvas(text, targetPx){
  const qr = qrcode(0, 'M'); // ECC M
  qr.addData(text);
  qr.make();
  const n = qr.getModuleCount();

  const c0 = document.createElement('canvas');
  c0.width = n; c0.height = n;
  const g = c0.getContext('2d',{alpha:false});
  g.fillStyle = '#FFF'; g.fillRect(0,0,n,n);
  g.fillStyle = '#000';
  for(let r=0;r<n;r++) for(let c=0;c<n;c++) if(qr.isDark(r,c)) g.fillRect(c,r,1,1);

  const c = document.createElement('canvas');
  c.width = targetPx; c.height = targetPx;
  const ctx = c.getContext('2d');
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(c0,0,0,targetPx,targetPx);
  return c;
}

/* ---------- PDF helpers ---------- */
function wrapTwoLinesFixed(pdf, text, maxPx, fontPx){
  pdf.setFontSize(fontPx);
  const lineH = Math.max(10, Math.floor(fontPx * 1.2));
  if (pdf.getTextWidth(text) <= maxPx) return {lines:[text], lineH};
  const tokens = text.split(/\s*\/\s*|\s+/).filter(Boolean);
  if (tokens.length < 2) return {lines:[text], lineH};

  let best=null;
  for (let cut=1; cut<tokens.length; cut++){
    const l1=tokens.slice(0,cut).join(' '), l2=tokens.slice(cut).join(' ');
    const w1=pdf.getTextWidth(l1), w2=pdf.getTextWidth(l2);
    const over=Math.max(w1-maxPx,w2-maxPx), worst=Math.max(w1,w2);
    const score=(over>0?over*1000:0)+worst;
    if(!best || score<best.score) best={lines:[l1,l2],score};
  }
  if (best) return {lines:best.lines, lineH};
  return {lines:[text], lineH};
}

/* ---------- PDF generation ---------- */
generateBtn.addEventListener('click', async ()=>{
  if(!(csvRows.length && templateDataURL && boxes.length)) return;

  generateBtn.disabled = true;
  generateBtn.textContent = 'Rendering‚Ä¶';
  try{
    const jsPDF = window.jspdf?.jsPDF || window.jsPDF;

    const img = await new Promise((resolve,reject)=>{
      const im = new Image(); im.onload=()=>resolve(im); im.onerror=reject; im.src=templateDataURL;
    });
    const imgW = img.naturalWidth  || img.width;
    const imgH = img.naturalHeight || img.height;

    // Scale CSS preview -> PDF pixels so label size matches the on-screen preview
    const displayW = (imgEl && imgEl.getBoundingClientRect ? (imgEl.getBoundingClientRect().width || imgW) : imgW) || imgW;
    const scalePx  = imgW / (displayW || imgW);
    const pdf = new jsPDF({orientation: imgW>imgH?'landscape':'portrait', unit:'px', format:[imgW,imgH], compress:true, putOnlyUsedFonts:true});

    // Background image once per page
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width=imgW; tempCanvas.height=imgH;
    tempCanvas.getContext('2d').drawImage(img,0,0,imgW,imgH);
    const pageJPEG = tempCanvas.toDataURL('image/jpeg', 0.9);

    let i=0, first=true;
    while(i < csvRows.length){
      if(!first) pdf.addPage([imgW,imgH]); else first=false;
      pdf.addImage(pageJPEG, 'JPEG', 0, 0, imgW, imgH);

      for (const b of boxes){
        if(i >= csvRows.length) break;
        const item = csvRows[i++];

        let x = toInt(b.xPct * imgW);
        let y = toInt(b.yPct * imgH);
        let size = toInt(b.sizePct * imgW);
        size = Math.max(1, Math.min(size, imgW - x, imgH - y));

        const qrCanvas = makeQRCanvas(item.uri, size);
        pdf.addImage(qrCanvas.toDataURL('image/png'), 'PNG', x, y, size, size);

        if (showText.checked){
          const label = buildLabel(item);
          if (label){
            const fontPx = Math.max(6, Math.floor(((labelFontPx||18) * scalePx))); 
            pdf.setFont('helvetica','bold');

            // label color
            if (typeof labelColor === 'string' && labelColor.startsWith('#')){
              const r=parseInt(labelColor.slice(1,3),16), g=parseInt(labelColor.slice(3,5),16), b=parseInt(labelColor.slice(5,7),16);
              pdf.setTextColor(r,g,b);
            }else pdf.setTextColor(140,140,140);

            const {lines, lineH} = wrapTwoLinesFixed(pdf, label, size, fontPx);
            const totalH = lineH * lines.length;
            const margin = Math.round(2 * scalePx);

            // Use saved label position (pct), fallback to under-QR if undefined
            let labelLeftPx = Math.round((typeof b.labelXPct === 'number' ? b.labelXPct : b.xPct) * imgW);
            let labelTopPx  = Math.round((typeof b.labelYPct === 'number' ? b.labelYPct  : (b.yPct + b.sizePct)) * imgH);

            // Clamp to page
            labelLeftPx = clamp(labelLeftPx, 0, imgW - size);
            labelTopPx  = clamp(labelTopPx,  0, imgH - totalH - margin);

            // Draw centered within label box width (same as QR size)
            let yCursor = labelTopPx;
            for(const ln of lines){
              const w = pdf.getTextWidth(ln);
              const xText = labelLeftPx + Math.round((size - w)/2);
              pdf.text(ln, xText, yCursor + lineH*0.8);
              yCursor += lineH;
            }
          }
        }
      }
    }

    pdf.save('qr-codes.pdf');
  }catch(err){
    console.error(err);
    alert('Error generating PDF: ' + (err?.message||err));
  }finally{
    generateBtn.disabled = false;
    generateBtn.textContent = '‚¨áÔ∏è Generate PDF';
  }
});

/* ---------- Clipboard paste (image or CSV) ---------- */
window.addEventListener('paste', async (e)=>{
  if(e.clipboardData && e.clipboardData.files && e.clipboardData.files.length){
    const img = Array.from(e.clipboardData.files).find(isImageFile);
    if(img){ e.preventDefault(); handleImage(img); return; }
  }
  const text = e.clipboardData?.getData('text/plain');
  if(text && text.trim()){
    e.preventDefault();
    const res = Papa.parse(text.trim(), {header:false, skipEmptyLines:true});
    if(res && Array.isArray(res.data) && res.data.length) parseRows(res.data);
  }
});
</script>
</body>
</html>
